<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Reikuron Particles</title>
    <style>
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
        }

        /* REIKURON HEADER */
        #header-bar {
            position: absolute; top: 0; left: 0; width: 100%;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            text-align: center;
            padding: 15px 0;
            pointer-events: none;
        }
        #brand-name {
            font-size: 2.5rem;
            font-weight: bold;
            color: #ff0055;
            text-shadow: 0 0 10px #ff0055, 0 0 20px #ff0000;
            letter-spacing: 5px;
            margin: 0;
            text-transform: uppercase;
        }

        /* CONTROLS INFO */
        #info-panel {
            position: absolute; bottom: 30px; left: 20px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            padding: 15px;
            border-left: 3px solid #ff0055;
            color: #fff;
            max-width: 300px;
        }
        p { margin: 5px 0; font-size: 0.85rem; color: #ddd; }
        .highlight { color: #fff; font-weight: bold; font-size: 1.1rem; text-transform: uppercase;}

        /* START OVERLAY */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto;
            transition: opacity 0.5s;
        }
        #start-btn {
            padding: 15px 50px; font-size: 1.2rem;
            background: transparent; border: 2px solid #ff0055;
            color: #ff0055; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 0, 85, 0.5);
            border-radius: 5px; margin-top: 20px;
        }
        #start-btn:hover { background: #ff0055; color: #000; }

        /* DEBUG VIDEO */
        #video-input {
            position: absolute; bottom: 10px; right: 10px;
            width: 80px; transform: scaleX(-1);
            border: 1px solid #333; opacity: 0.5; display: none;
        }
        
        #loading { color: #555; margin-top: 10px; font-size: 0.8rem; display: none; }
        #error-msg { color: red; margin-top: 20px; text-align: center; }
    </style>
</head>
<body>

    <!-- START SCREEN -->
    <div id="start-overlay">
        <h1 style="color:white; letter-spacing:3px;">SYSTEM OF REIKURON</h1>
        <button id="start-btn">INITIALIZE SYSTEM</button>
        <div id="loading">Loading Neural Network...</div>
        <div id="error-msg"></div>
    </div>

    <!-- UI -->
    <div id="ui-layer">
        <div id="header-bar">
            <h1 id="brand-name">REIKURON</h1>
        </div>
        <div id="info-panel">
            <p class="highlight" id="shape-name">Sphere</p>
            <p>üëã Move Hand to Attract</p>
            <p>ü§è Pinch to Switch Shape</p>
            <p>‚ÜîÔ∏è Hand X changes Color</p>
        </div>
    </div>

    <video id="video-input" playsinline webkit-playsinline muted autoplay></video>

    <!-- LIBS -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIG ---
        const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
        const PARTICLE_COUNT = isMobile ? 7000 : 20000;
        const PARTICLE_SIZE = isMobile ? 0.2 : 0.09;
        
        // --- GLOBALS ---
        let scene, camera, renderer, particles, handCursor;
        let positions, colors, targetPositions;
        let handPosition = new THREE.Vector3(0, 0, 0);
        let smoothedHandPos = new THREE.Vector3(0, 0, 0);
        let isHandPresent = false;
        let isPinching = false, wasPinching = false;
        let currentShapeIndex = 0;
        let time = 0;

        // SHAPE LIST
        const SHAPES = ['Sphere', 'Reikuron Crow', 'Itachi Sharingan', 'Heart', 'Galaxy', 'DNA'];

        // --- 1. THREE.JS ENGINE ---
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 35;

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Hand Cursor (Visual Feedback)
            const cursorGeo = new THREE.RingGeometry(0.5, 0.6, 32);
            const cursorMat = new THREE.MeshBasicMaterial({ color: 0xff0055, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
            handCursor = new THREE.Mesh(cursorGeo, cursorMat);
            handCursor.visible = false;
            scene.add(handCursor);

            createParticles();
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            animate();
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            targetPositions = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                positions[i*3] = (Math.random()-0.5)*50;
                positions[i*3+1] = (Math.random()-0.5)*50;
                positions[i*3+2] = (Math.random()-0.5)*50;
                
                colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.85
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
            generateShape(0);
        }

        // --- 2. SHAPE GENERATOR ---
        function generateShape(index) {
            currentShapeIndex = index;
            document.getElementById('shape-name').innerText = SHAPES[index];
            const scale = 10;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                const i3 = i * 3;

                if (index === 0) { // Sphere
                    const phi = Math.acos(-1 + (2 * i) / PARTICLE_COUNT);
                    const theta = Math.sqrt(PARTICLE_COUNT * Math.PI) * phi;
                    x = scale * Math.cos(theta) * Math.sin(phi);
                    y = scale * Math.sin(theta) * Math.sin(phi);
                    z = scale * Math.cos(phi);
                }
                else if (index === 1) { // THE CROW
                    const r = i / PARTICLE_COUNT;
                    // Body (Central mass)
                    if (i < PARTICLE_COUNT * 0.3) {
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.random() * Math.PI;
                        const rad = Math.random() * 2;
                        // Elongated body
                        x = rad * Math.cos(theta) * Math.sin(phi);
                        y = rad * Math.sin(theta) * Math.sin(phi) * 0.5;
                        z = (rad * Math.cos(phi) * 3) + 2; 
                    } else {
                        // Wings (V Shape)
                        const t = (i - PARTICLE_COUNT * 0.3) / (PARTICLE_COUNT * 0.7); // 0 to 1
                        const side = i % 2 === 0 ? 1 : -1;
                        const wingSpan = 18;
                        const wingWidth = Math.random() * 3;
                        
                        // Parabolic wing shape
                        x = side * (2 + t * wingSpan); 
                        z = -Math.abs(x) * 0.3 + (Math.random()-0.5); // Angled back
                        // Flapping curve (Sine wave arch)
                        y = Math.sin(t * Math.PI) * 5 + (Math.random()-0.5); 
                    }
                }
                else if (index === 2) { // ITACHI SHARINGAN
                    // Mangekyou Pinwheel Pattern
                    const section = i % 3; // 3 blades
                    const t = Math.random(); 
                    const angleOffset = (section * (Math.PI * 2 / 3));
                    
                    // Spiral formula for blades
                    const radius = t * 12;
                    const spiralAngle = t * 3 + angleOffset; // Curvature
                    
                    x = Math.cos(spiralAngle) * radius;
                    y = Math.sin(spiralAngle) * radius;
                    z = (Math.random() - 0.5); // Flat disk
                    
                    // Add outer ring for definition
                    if (i > PARTICLE_COUNT * 0.9) {
                        const theta = (i / (PARTICLE_COUNT*0.1)) * Math.PI * 2;
                        x = Math.cos(theta) * 12.5;
                        y = Math.sin(theta) * 12.5;
                        z = 0;
                    }
                }
                else if (index === 3) { // Heart
                    const t = i * 0.1;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random()-0.5)*4;
                    x *= 0.5; y *= 0.5;
                }
                else if (index === 4) { // Galaxy
                    const angle = i * 0.05;
                    const r = (i / PARTICLE_COUNT) * 20;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                    y = (Math.random() - 0.5) * (20 - r) * 0.2; // Bulge at center
                }
                else if (index === 5) { // DNA
                    const t = i * 0.05;
                    const r = 5;
                    x = Math.cos(t) * r;
                    z = Math.sin(t) * r;
                    y = (i / PARTICLE_COUNT - 0.5) * 40;
                    // Double strand separation
                    if (i % 2 === 0) { x *= -1; z *= -1; }
                }

                targetPositions[i3] = x;
                targetPositions[i3 + 1] = y;
                targetPositions[i3 + 2] = z;
            }
        }

        // --- 3. ANIMATION & PHYSICS ---
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            const pos = particles.geometry.attributes.position.array;
            const col = particles.geometry.attributes.color.array;

            // Smooth Hand
            smoothedHandPos.lerp(handPosition, 0.1);
            
            // Cursor update
            if(isHandPresent) {
                handCursor.position.copy(smoothedHandPos);
                handCursor.visible = true;
                // Pulse effect
                const s = 1 + Math.sin(time * 10) * 0.2;
                handCursor.scale.set(s,s,s);
            } else {
                handCursor.visible = false;
            }

            // Logic for Itachi (Red/Black Theme)
            let isItachi = (currentShapeIndex === 2);
            let targetHue = 0.0; // Red for Itachi
            
            if (!isItachi) {
                // Normal color mapping based on hand X
                if(isHandPresent) targetHue = (smoothedHandPos.x + 15) / 30;
                else targetHue = (Math.sin(time * 0.2) + 1) / 2;
            }

            // Switch Shape on Pinch
            if (isPinching && !wasPinching) {
                generateShape((currentShapeIndex + 1) % SHAPES.length);
                // Trigger visual feedback (Screen Flash)
                document.getElementById('header-bar').style.background = `linear-gradient(to bottom, rgba(255,0,85,0.8), transparent)`;
                setTimeout(() => {
                    document.getElementById('header-bar').style.background = `linear-gradient(to bottom, rgba(0,0,0,0.9), transparent)`;
                }, 200);
            }
            wasPinching = isPinching;

            // Physics Loop
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // 1. Home Force (Go to shape)
                let tx = targetPositions[i3];
                let ty = targetPositions[i3 + 1];
                let tz = targetPositions[i3 + 2];

                // Add "Life" to Crow (Flapping)
                if (currentShapeIndex === 1 && i > PARTICLE_COUNT * 0.3) {
                    ty += Math.sin(time * 5 + tx * 0.2) * 2; 
                }
                // Add Rotation to Sharingan
                if (currentShapeIndex === 2) {
                    const rotSpeed = 0.02; // Spin the eye
                    const x = tx; const y = ty;
                    tx = x * Math.cos(rotSpeed) - y * Math.sin(rotSpeed);
                    ty = x * Math.sin(rotSpeed) + y * Math.cos(rotSpeed);
                    targetPositions[i3] = tx; // Save back for next frame accumulation
                    targetPositions[i3+1] = ty;
                }

                let vx = (tx - pos[i3]) * 0.05;
                let vy = (ty - pos[i3 + 1]) * 0.05;
                let vz = (tz - pos[i3 + 2]) * 0.05;

                // 2. Hand Force
                if (isHandPresent) {
                    const dx = pos[i3] - smoothedHandPos.x;
                    const dy = pos[i3 + 1] - smoothedHandPos.y;
                    const dz = pos[i3 + 2] - smoothedHandPos.z;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    if (isPinching) {
                        // Chibaku Tensei / Explosion
                        if(distSq < 200) {
                            const force = 4.0 / (Math.sqrt(distSq) + 0.1);
                            vx += dx * force; vy += dy * force; vz += dz * force;
                        }
                    } else {
                        // Attraction
                        if(distSq < 400) {
                            const force = (20 - Math.sqrt(distSq)) * 0.003;
                            vx -= dx * force; vy -= dy * force; vz -= dz * force;
                        }
                    }
                }

                pos[i3] += vx;
                pos[i3 + 1] += vy;
                pos[i3 + 2] += vz;

                // Color Logic
                if (isItachi) {
                    // Deep Red and Black
                    const isRed = i % 3 === 0; // Mix black and red
                    const c = new THREE.Color(isRed ? 0xff0000 : 0x110000);
                    // Add subtle glow based on hand distance
                    if(isHandPresent) c.offsetHSL(0, 0, 0.1);
                    
                    col[i3] = c.r; col[i3+1] = c.g; col[i3+2] = c.b;
                } else {
                    // Normal Rainbow Logic
                    const c = new THREE.Color().setRGB(col[i3], col[i3+1], col[i3+2]);
                    const t = new THREE.Color().setHSL(Math.abs(targetHue), 0.8, 0.5);
                    c.lerp(t, 0.05);
                    col[i3] = c.r; col[i3+1] = c.g; col[i3+2] = c.b;
                }
            }

            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true;
            
            // Slow global rotation
            if (currentShapeIndex !== 2) { // Don't rotate Sharingan globally, it rotates internally
                particles.rotation.y += 0.001;
            }

            renderer.render(scene, camera);
        }

        // --- 4. MEDIA PIPE ---
        async function startSystem() {
            document.getElementById('start-btn').style.display = 'none';
            document.getElementById('loading').style.display = 'block';
            
            // HTTPS Check
            if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {
                document.getElementById('error-msg').innerHTML = "ERROR: Project requires HTTPS or Localhost.";
                return;
            }

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: isMobile ? 0 : 1, // 0 is faster
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                const overlay = document.getElementById('start-overlay');
                if(overlay.style.opacity !== '0') {
                    overlay.style.opacity = '0';
                    setTimeout(() => overlay.style.display = 'none', 500);
                }

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isHandPresent = true;
                    const lm = results.multiHandLandmarks[0];
                    const index = lm[8];
                    const thumb = lm[4];

                    // Map Video Coords (0-1) to 3D World Coords
                    const x = (0.5 - index.x) * 30;
                    const y = (0.5 - index.y) * 20;
                    
                    handPosition.set(x, y, 0);

                    // Pinch Check
                    const d = Math.sqrt(Math.pow(index.x - thumb.x, 2) + Math.pow(index.y - thumb.y, 2));
                    isPinching = (d < 0.06);
                } else {
                    isHandPresent = false;
                }
            });

            const video = document.getElementById('video-input');
            try {
                // Initialize Three.js now
                initThree();
                
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'user', width: { ideal: 640 }, height: { ideal: 480 } } 
                });
                video.srcObject = stream;
                await video.play();

                const cameraUtils = new Camera(video, {
                    onFrame: async () => await hands.send({image: video}),
                    width: 640, height: 480
                });
                cameraUtils.start();

            } catch (err) {
                console.error(err);
                document.getElementById('error-msg').innerText = "Camera Access Failed. Check permissions.";
            }
        }

        document.getElementById('start-btn').addEventListener('click', startSystem);

    </script>
</body>
</html>
